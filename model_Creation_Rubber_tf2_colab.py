# -*- coding: utf-8 -*-
"""Rubber_Duck_Zombie_object_detection_tf2_colab.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ck6rO34x1cPjAXN-9qQLDuuzYwq-qQYP

# Eager Few Shot Object Detection Colab

Welcome to the Eager Few Shot Object Detection Colab --- in this colab we demonstrate fine tuning of a (TF2 friendly) RetinaNet architecture on very few examples of a novel class after initializing from a pre-trained COCO checkpoint.
Training runs in eager mode.

Estimated time to run through this colab (with GPU): < 5 minutes.

## Imports
"""

# !pip install -U --pre tensorflow=="2.2.0"

import matplotlib.pyplot as plt

import os , sys
import random
import numpy as np

import tensorflow as tf

from object_detection.utils import label_map_util
from object_detection.utils import config_util
from object_detection.utils import visualization_utils as viz_utils
# from object_detection.utils import colab_utils
from object_detection.builders import model_builder

# checking that GPU is found
import Ultils_model_creation

## 0 INTRO TF OPCION
gpus = tf.config.list_physical_devices('GPU')
# gpus = tf.config.experimental.list_physical_devices('GPU')

if gpus:
  print("Restrict TensorFlow to only use the first GPU")
  try:
    tf.config.experimental.set_memory_growth(gpus[0], True)
    tf.config.set_visible_devices(gpus[0], 'GPU')
    logical_gpus = tf.config.list_logical_devices('GPU')
    print(len(gpus), "Physical GPUs,", len(logical_gpus), "Logical GPU")
  except RuntimeError as e:
    # Visible devices must be set before GPUs have been initialized
    print(e)

sys.setrecursionlimit(6000)
#https://github.com/tensorflow/tensorflow/issues/48545
os.environ["TF_GPU_ALLOCATOR"]="cuda_malloc_async"
os.environ["TF_CPP_VMODULE"]="gpu_process_state=10,gpu_cudamallocasync_allocator=10"
    # 0 = all messages are logged (default behavior)
    # 1 = INFO messages are not printed
    # 2 = INFO and WARNING messages are not printed
    # 3 = INFO, WARNING, and ERROR messages are not printed
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'
#RECOMENTED allow growth memonry use
os.environ['TF_FORCE_GPU_ALLOW_GROWTH'] = 'true'

# %matplotlib inline
# physical_devices = tf.config.experimental.list_physical_devices('GPU')
# tf.config.experimental.set_memory_growth(physical_devices[0], True)
# # Assume that you have 12GB of GPU memory and want to allocate ~4GB:
gpu_options = tf.compat.v1.GPUOptions(per_process_gpu_memory_fraction=0.333)
sess = tf.compat.v1.Session(config=tf.compat.v1.ConfigProto(gpu_options=gpu_options))
"""# Utilities"""


"""# Rubber Ducky data

We will start with some toy (literally) data consisting of 5 images of a rubber
ducky.  Note that the [coco](https://cocodataset.org/#explore) dataset contains a number of animals, but notably, it does *not* contain rubber duckies (or even ducks for that matter), so this is a novel class.
"""


## 0.1 LOAD PARAM CONFIG bbox
plt = Ultils_model_creation.plot_parameter_setup_config(plt)
#
# for idx, train_image_np in enumerate(train_images_np):
#   plt.subplot(2, 3, idx+1)
#   plt.imshow(train_image_np)
# plt.show()

#LUIS 
# 1.0 LOAD the imagenes with bbox or segmentation
train_image_dir = 'img_zombi_cat_dog'
list_train_images_np = []

# run a for loop for each image
for i in range(1, 6):
    path_img_to_train = os.path.join(train_image_dir, 'training-zombie' + str(i) + '.jpg')
    # load images into numpy arrays and append to a list
    list_train_images_np.append( Ultils_model_creation.load_image_into_numpy_array(path_img_to_train))

#DOG vs CAT
for cat_dog in ['cat', 'dog']:
  for i in range(0, 8):#Luis Code extra
      path_img_to_train = os.path.join(train_image_dir, cat_dog+ '.' + str(i) + '.jpg')
      # load images into numpy arrays and append to a list
      list_train_images_np.append( Ultils_model_creation.load_image_into_numpy_array(path_img_to_train))
print("Images are loaded for train len(list) : ", len(list_train_images_np))

"""# Annotate images with bounding boxes
In this cell you will annotate the rubber duckies --- draw a box around the rubber ducky in each image; click `next image` to go to the next image and `submit` when there are no more images.
If you'd like to skip the manual annotation step, we totally understand.  In this case, simply skip this cell and run the next cell instead, where we've prepopulated the groundtruth with pre-annotated bounding boxes.
"""
## 0.2 LABELS bbox
#Only for zombies
ref_gt_boxes = [
        np.array([[0.27333333, 0.41500586, 0.74333333, 0.57678781]]), #C:\Users\Luis\Desktop\Object_detec\training\training-zombie1.jpg
        np.array([[0.29833333, 0.45955451, 0.75666667, 0.61078546]]),
        np.array([[0.40833333, 0.18288394, 0.945, 0.34818288]]),
        np.array([[0.16166667, 0.61899179, 0.8, 0.91910903]]),
        np.array([[0.28833333, 0.12543962, 0.835, 0.35052755]]), #C:\Users\Luis\Desktop\Object_detec\training\training-zombie5.jpg

np.array([[0.04064394, 0.226     , 0.65897727, 0.716     ]]),#cat.0.jpg
 np.array([[0.10897727, 0.15333333, 0.99064394, 0.90666667]]),
 np.array([[0.04231061, 0.14423077, 0.97064394, 0.86858974]]),
 np.array([[0.00397727, 0.008     , 0.91564394, 0.942     ]]),
 np.array([[0.08564394, 0.17835671, 0.95397727, 0.9759519 ]]),
 np.array([[0.37397727, 0.14285714, 0.81231061, 0.70857143]]),
 np.array([[0.39231061, 0.1425    , 0.76231061, 0.465     ]]),
 np.array([[0.03897727, 0.31919192, 0.98731061, 0.96363636]]),#cat.7.jpg

np.array([[0.06397727, 0.15831663, 0.82397727, 0.75350701]]),#dog.0.jpg
 np.array([[0.10564394, 0.18042813, 0.94397727, 0.88073394]]),
 np.array([[0.23064394, 0.36898396, 0.92064394, 0.85561497]]),
 np.array([[0.        , 0.06813627, 0.97397727, 0.99398798]]),
 np.array([[0.01897727, 0.14      , 0.98564394, 0.84666667]]),
 np.array([[0.01064394, 0.250501  , 0.85897727, 0.59719439]]),
 np.array([[0.15064394, 0.09218437, 0.96564394, 0.91583166]]),
 np.array([[0.13231061, 0., 0.96731061, 0.46488294] ])        #dog.7.jpg
           # , [0.24897727, 0.84280936, 0.64731061, 1.]])       		#cat.7.jpg
      ]
gt_boxes = ref_gt_boxes

"""# Prepare data for training

Below we add the class annotations (for simplicity, we assume a single class in this colab; though it should be straightforward to extend this to handle multiple classes).  We also convert everything to the format that the training
loop below expects (e.g., everything converted to tensors, classes converted to one-hot representations, etc.).
"""

## 0.2.1 LABELS bbox with Clasese


#Add clasifier label , Assign the zombie class ID
gt_classes = [1,1,1,1,1,  2,2,2,2,2,2,2,2,  3,3,3,3,3,3,3,3]
# gt_classes = [[1],[1],[1],[1],[1], [2],[2],[2],[2],[2],[2],[2],[2], [3],[3],[3],[3],[3],[3],[3],[3,2]]

# By convention, our non-background classes start counting at 1.  Given
# that we will be predicting just one class, we will therefore assign it a
# `class id` of 1.
# duck_class_id = 1
category_index = Ultils_model_creation.get_category_index()
NUM_CLASSES = len(category_index)
num_classes = NUM_CLASSES

# category_index = {duck_class_id: {'id': duck_class_id, 'name': 'rubber_ducky'}}



# Convert class labels to one-hot; convert everything to tensors.
# The `label_id_offset` here shifts all classes by a certain number of indices;
# we do this here so that the model receives one-hot labels where non-background
# classes start counting at the zeroth index.  This is ordinarily just handled
# automatically in our training binaries, but we need to reproduce it here.


## 1 GENERATE GoundTrue
label_id_offset = 1
train_image_tensors = []
gt_classes_one_hot_tensors = []
gt_box_tensors = []
# for (train_image_np, gt_box_np) in zip(train_images_np, gt_boxes):
#INFO https://github.com/tensorflow/models/issues/9655#issuecomment-1461904991
for (train_image_np, gt_box_np, gt_class) in zip(list_train_images_np, gt_boxes, gt_classes):
  train_image_tensors.append(tf.expand_dims(tf.convert_to_tensor(
      train_image_np, dtype=tf.float32), axis=0))
  gt_box_tensors.append(tf.convert_to_tensor(gt_box_np, dtype=tf.float32))
  aa_hot = tf.one_hot(indices=(gt_class - label_id_offset), depth= num_classes, dtype=tf.float32)
  # bb_hot = tf.reshape(aa_hot, [-1, num_classes ]  )
  gt_classes_one_hot_tensors.append( tf.reshape( aa_hot , [-1, num_classes])   )

print('Done prepping data   len(list) : ', len(list_train_images_np) )

"""# Let's just visualize the rubber duckies as a sanity check
"""

## 1.1 VISUALIZATE GoundTrue
# use the `plot_detections()` utility function to draw the ground truth boxes
#TODO no se escala facilmente
dummy_scores = np.array([1.0], dtype=np.float32)
for idx in range(len(list_train_images_np)):
    plt.subplot(7, 4, idx+1)
    Ultils_model_creation.plot_detections(
      image_np = list_train_images_np[idx],
      boxes = gt_boxes[idx],
      classes = [gt_classes[idx] ] ,#LUIS np.ones(shape=[gt_boxes[idx].shape[0]], dtype=np.int32),
      scores = dummy_scores, category_index = category_index)
plt.savefig(" mosaico_ALL_labels.png", bbox_inches='tight')
print(" mosaico_ALL_labels.png")
# plt.show()

# dummy_scores = np.array([1.0], dtype=np.float32)  # give boxes a score of 100%

# plt.figure(figsize=(30, 15))
# for idx in range(5):
#   plt.subplot(2, 3, idx+1)
#   plot_detections(
#       train_images_np[idx],
#       gt_boxes[idx],
#       np.ones(shape=[gt_boxes[idx].shape[0]], dtype=np.int32),
#       dummy_scores, category_index)
# plt.show()

# np.ones(shape=[gt_boxes[idx].shape[0]], dtype=np.int32)

"""# Create model and restore weights for all but last layer
In this cell we build a single stage detection architecture (RetinaNet) and restore all but the classification layer at the top (which will be automatically randomly initialized).
For simplicity, we have hardcoded a number of things in this colab for the specific RetinaNet architecture at hand (including assuming that the image size will always be 640x640), however it is not difficult to generalize to other model configurations.
"""

## 2.1 DOWNLOAD preTrain model to tranfers
# Download the checkpoint and put it into models/research/object_detection/test_data/

# !wget http://download.tensorflow.org/models/object_detection/tf2/20200711/ssd_resnet50_v1_fpn_640x640_coco17_tpu-8.tar.gz
# !tar -xf ssd_resnet50_v1_fpn_640x640_coco17_tpu-8.tar.gz
# !mv ssd_resnet50_v1_fpn_640x640_coco17_tpu-8/checkpoint models/research/object_detection/test_data/

tf.keras.backend.clear_session()

print('Building model and restoring weights for fine-tuning...', flush=True)

PATH_TRANSFER =  'ssd_resnet101_v1_fpn_640x640' #'ssd_mobilenet_v2_fpnlite_640x640'
PATH_MODELS_CHECKPOINT_STEP_STPE = 'model_101_D'

PATH_MODEL_TRANSFER_PIPE = PATH_TRANSFER +'/pipeline.config'
PATH_MODEL_TRANSFER_CHECK = PATH_TRANSFER +'/checkpoint/ckpt-0'
print('\t'+PATH_MODEL_TRANSFER_PIPE)

# pipeline_config = 'ssd_mobilenet_v2_fpnlite_640x640_coco17_tpu-8/pipeline.config'
# checkpoint_path = 'ssd_mobilenet_v2_fpnlite_640x640_coco17_tpu-8/checkpoint/ckpt-0'

## 2.2 COnfigure the new  pipeline.config and saved the new
# Load pipeline config and build a detection model. Since we are working off of a COCO architecture which predicts 90
# class slots by default, we override the `num_classes` field here to be justone (for our new rubber ducky class).
configs = config_util.get_configs_from_pipeline_file(PATH_MODEL_TRANSFER_PIPE)
configs['train_config'].fine_tune_checkpoint_type = "detection"
configs['train_config'].fine_tune_checkpoint = PATH_MODEL_TRANSFER_CHECK
configs['model'].ssd.num_classes = num_classes
configs['model'].ssd.freeze_batchnorm = True
detection_model = model_builder.build(
      model_config=configs['model'], is_training=True)
pipeline_proto = config_util.create_pipeline_proto_from_configs(configs)
config_util.save_pipeline_config(pipeline_proto,PATH_MODELS_CHECKPOINT_STEP_STPE )
print("Created: "+ PATH_MODELS_CHECKPOINT_STEP_STPE+"/pipeline_config")

## 2.3 CLEAN the Checkpoint and Weights restored!
# Set up object-based checkpoint restore --- RetinaNet has two prediction
# `heads` --- one for classification, the other for box regression.  We will
# restore the box regression head but initialize the classification head
# from scratch (we show the omission below by commenting out the line that we would add if we wanted to restore both heads)
fake_box_predictor = tf.compat.v2.train.Checkpoint(
    _base_tower_layers_for_heads=detection_model._box_predictor._base_tower_layers_for_heads,
    # _prediction_heads=detection_model._box_predictor._prediction_heads,
    #    (i.e., the classification head that we *will not* restore)
    _box_prediction_head=detection_model._box_predictor._box_prediction_head,
    )
fake_model = tf.compat.v2.train.Checkpoint(
          _feature_extractor=detection_model._feature_extractor,
          _box_predictor=fake_box_predictor)
ckpt = tf.compat.v2.train.Checkpoint(model=fake_model)
ckpt.restore(PATH_MODEL_TRANSFER_CHECK).expect_partial()

# Run model through a dummy image so that variables are created
image, shapes = detection_model.preprocess(tf.zeros([1, 640, 640, 3]))
prediction_dict = detection_model.predict(image, shapes)
_ = detection_model.postprocess(prediction_dict, shapes)
print('Weights restored!')
"""# Eager mode custom training loop"""

# 3.0 TRAIN the models
# Set up forward + backward pass for a single train step.
def get_model_train_step_function(model, optimizer, vars_to_fine_tune):
  """Get a tf.function for training step."""

  # Use tf.function for a bit of speed.
  # Comment out the tf.function decorator if you want the inside of the
  # function to run eagerly.
  @tf.function
  def train_step_fn(image_tensors,
                    groundtruth_boxes_list,
                    groundtruth_classes_list):
    """A single training iteration.

    Args:
      image_tensors: A list of [1, height, width, 3] Tensor of type tf.float32.
        Note that the height and width can vary across images, as they are
        reshaped within this function to be 640x640.
      groundtruth_boxes_list: A list of Tensors of shape [N_i, 4] with type
        tf.float32 representing groundtruth boxes for each image in the batch.
      groundtruth_classes_list: A list of Tensors of shape [N_i, num_classes]
        with type tf.float32 representing groundtruth boxes for each image in
        the batch.

    Returns:
      A scalar tensor representing the total loss for the input batch.
    """
    shapes = tf.constant(BACHT_SIZE * [[640, 640, 3]], dtype=tf.int32)
    # print("groundtruth_boxes_list.shape: ",len(groundtruth_boxes_list) , " groundtruth_classes_list: ",  len(groundtruth_classes_list) )
    # print("groundtruth_boxes_list[0].shape: ",groundtruth_boxes_list[0].shape , " groundtruth_classes_list[0]: ",  groundtruth_classes_list[0].shape )
    model.provide_groundtruth(
        groundtruth_boxes_list=groundtruth_boxes_list,
        groundtruth_classes_list=groundtruth_classes_list)
    with tf.GradientTape() as tape:
      preprocessed_images = tf.concat( [detection_model.preprocess(image_tensor)[0] for image_tensor in image_tensors], axis=0)
      # print("preprocessed_images.shape: ",preprocessed_images.shape , " shapes: ", shapes)
      prediction_dict = model.predict(preprocessed_images, shapes)
      #prediction_dict por donde va creyendo que funciona
      losses_dict = model.loss(prediction_dict, shapes)
      # losses_dict cuanto esta mejorando
      total_loss = losses_dict['Loss/localization_loss'] + losses_dict['Loss/classification_loss']
      gradients = tape.gradient(total_loss, vars_to_fine_tune)
      #vars_to_fine_tune por donde han ido el intento de poner las bbox
      optimizer.apply_gradients(zip(gradients, vars_to_fine_tune))
    return total_loss

  return train_step_fn

tf.keras.backend.set_learning_phase(True)

# These parameters can be tuned; since our training set has 5 images
# it doesn't make sense to have a much larger batch size, though we could
# fit more examples in memory if we wanted to.
BACHT_SIZE = 5
learning_rate = 0.01
NUM_BATCHES = 150

# Select variables in top layers to fine-tune.
trainable_variables = detection_model.trainable_variables
to_fine_tune = []
prefixes_to_train = [
  'WeightSharedConvolutionalBoxPredictor/WeightSharedConvolutionalBoxHead',
  'WeightSharedConvolutionalBoxPredictor/WeightSharedConvolutionalClassHead']
for var in trainable_variables:
  if any([var.name.startswith(prefix) for prefix in prefixes_to_train]):
    to_fine_tune.append(var)


optimizer = tf.keras.optimizers.SGD(learning_rate=learning_rate, momentum=0.9)
train_step_fn = get_model_train_step_function( detection_model, optimizer, to_fine_tune)


#Checkpoint manager https://www.tensorflow.org/guide/checkpoint?hl=es-419
exported_ckpt_new = tf.compat.v2.train.Checkpoint(model=detection_model) #tf.train.Checkpoint(model=detection_model)
manager_ckpt_new = tf.train.CheckpointManager(exported_ckpt_new, directory=PATH_MODELS_CHECKPOINT_STEP_STPE + "/checkpoint/", max_to_keep=2 ) #manager_ckpt = tf.train.CheckpointManager(ckpt, './tf_ckpts', max_to_keep=3)

ckpt.restore(manager_ckpt_new.latest_checkpoint)
if manager_ckpt_new.latest_checkpoint:
    print("WARN (es nuevo ??) Restaurado de {}".format(manager_ckpt_new.latest_checkpoint))
    print("WARN (es nuevo ??) Restaurado de {}".format(manager_ckpt_new.latest_checkpoint))
else:
    print("Inicializando desde cero Path: ",PATH_MODELS_CHECKPOINT_STEP_STPE + "/checkpoint/")

# If you're using a pre-trained model, freeze the first layers (like this)
# https://stackoverflow.com/questions/59394947/how-to-fix-resourceexhaustederror-oom-when-allocating-tensor
# detection_model.layers[0].trainable = False  # Freeze ResNet50Base.

print('Start fine-tuning!', flush=True)
for idx in range(NUM_BATCHES):
  # Grab keys for a random subset of examples
  all_keys = list(range(len(list_train_images_np)))
  random.shuffle(all_keys)
  example_keys = all_keys[:BACHT_SIZE]

  # Note that we do not do data augmentation in this demo.  If you want a
  # a fun exercise, we recommend experimenting with random horizontal flipping and random cropping :)
  # GET the GT , clases and boxes
  gt_boxes_list = [gt_box_tensors[key] for key in example_keys]
  gt_classes_list = [gt_classes_one_hot_tensors[key] for key in example_keys]
  # GET the imagenes array-tensor
  image_tensors = [train_image_tensors[key] for key in example_keys]

  # Training step (forward pass + backwards pass)
  total_loss  = train_step_fn(image_tensors, gt_boxes_list, gt_classes_list)

  # PATH_MODELS_CHECK_EXPT = 'model_cat_dog_zombie/export'
  # print('Done export model path: ', PATH_MODELS_CHECK_EXPT)
  # detection_model.export(export_dir=PATH_MODELS_CHECK_EXPT, export_format=[ExportFormat.TFLITE, ExportFormat.SAVED_MODEL, ExportFormat.LABEL, ExportFormat.VOCAB , ExportFormat.TFJS])

  if idx % 10 == 0:
    print('\nbatch ' + str(idx) + ' of ' + str(NUM_BATCHES)+ ', loss=' +  str(total_loss.numpy()), flush=True)
    print("DEBUG:  example_keys : ", example_keys)
    save_path = manager_ckpt_new.save()
    print("Checkpoint almacenado para el STEP: {}: {}".format(int(exported_ckpt_new.save_counter.numpy()), save_path),"  List_checkpoints:" , manager_ckpt_new.checkpoints)

  print("\t"+  str(round(total_loss.numpy() , 3)), end="", flush=True)


print('Done fine-tuning!')



#SAVE like checkpoint the traied model  https://github.com/tensorflow/models/issues/8862
Ultils_model_creation.save_detecion_pd_checkpoint(detection_model, PATH_MODELS_CHECKPOINT_STEP_STPE, configs)

"""# Load test images and run inference with new model!"""
list_test_images_np = Ultils_model_creation.get_valitation_images()


# Again, uncomment this decorator if you want to run inference eagerly
@tf.function(input_signature=[tf.TensorSpec(shape=[None,640,640,3], dtype=tf.float32)])
def detect(input_tensor):
  """Run detection on an input image.

  Args:
    input_tensor: A [1, height, width, 3] Tensor of type tf.float32.
      Note that height and width can be anything since the image will be
      immediately resized according to the needs of the model within this
      function.

  Returns:
    A dict containing 3 Tensors (`detection_boxes`, `detection_classes`,
      and `detection_scores`).
  """
  preprocessed_image, shapes = detection_model.preprocess(input_tensor)
  prediction_dict = detection_model.predict(preprocessed_image, shapes)
  return detection_model.postprocess(prediction_dict, shapes)


tf.saved_model.save(
    detection_model , PATH_MODELS_CHECKPOINT_STEP_STPE+'/save_model_detect',
    signatures={
      'detect': detect.get_concrete_function()
    })
print("Saved with 'detect' signature in: ", PATH_MODELS_CHECKPOINT_STEP_STPE+'/save_model_detect')
print("EVALUAR en model_Detect_sig_detect.py con la ruta: ", PATH_MODELS_CHECKPOINT_STEP_STPE+'/save_model_detect')
# Note that the first frame will trigger tracing of the tf.function, which will
# take some time, after which inference should be fast.

# label_id_offset = 1
# for i in  range(len(list_test_images_np)):
#   input_tensor = tf.convert_to_tensor(list_test_images_np[i], dtype=tf.float32)
#   # input_tensor = tf.expand_dims(tf.convert_to_tensor(test_images_np[i], dtype=tf.float32), axis=0)
#   print("img_cat_dogs_test_valida_result/atest_" + ('%02d' % i) + ".jpg  shape: ",input_tensor.shape)
#   detections = detect(input_tensor)
#
#   print("img_cat_dogs_test_valida_result/atest_" + ('%02d' % i) + ".jpg", "Probability: ", detections['detection_scores'][0][0].numpy(),
#       "Classes: ", detections['detection_classes'][0][0].numpy().astype(np.uint32) + label_id_offset,
#       "Boxes: ", detections['detection_boxes'][0][0].numpy())
#
#   Ultils_model_creation.plot_detections(
#       list_test_images_np[i][0],
#       detections['detection_boxes'][0].numpy(),
#       detections['detection_classes'][0].numpy().astype(np.uint32)
#       + label_id_offset,
#       detections['detection_scores'][0].numpy(),
#       category_index, figsize=(15, 20), image_name="img_cat_dogs_test_valida_result/atest_" + ('%02d' % i) + ".jpg")

